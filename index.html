<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber-Scribe | Transcripción Futurista</title>
    
    <!-- Tailwind CSS para el diseño -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts para una tipografía cyberpunk -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- Librería jsPDF para generar PDFs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* Estilos personalizados para la estética Cyberpunk */
        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #0a0a1a;
            color: #00faff;
            background-image: 
                linear-gradient(rgba(10, 10, 26, 0.95), rgba(10, 10, 26, 0.95)),
                url('https://www.transparenttextures.com/patterns/cubes.png');
        }

        .neon-text {
            text-shadow:
                0 0 5px #00faff,
                0 0 10px #00faff,
                0 0 20px #00faff,
                0 0 40px #ff00ff,
                0 0 80px #ff00ff;
        }

        .cyber-button {
            background-color: transparent;
            border: 2px solid #00faff;
            color: #00faff;
            padding: 10px 20px;
            transition: all 0.3s ease;
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%);
        }

        .cyber-button:hover:not(:disabled) {
            background-color: #00faff;
            color: #0a0a1a;
            box-shadow: 0 0 15px #00faff;
        }
        
        .cyber-button:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        
        .cyber-panel {
            background-color: rgba(13, 27, 42, 0.8);
            border: 1px solid #ff00ff;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }
        
        textarea {
            background-color: rgba(0,0,0,0.5);
            border: 1px solid #00faff;
            color: #e0e0e0;
        }

        textarea:focus {
            outline: none;
            border-color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-4xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-5xl md:text-6xl font-bold neon-text">Cyber-Scribe</h1>
            <p class="text-fuchsia-400 mt-2">Iniciando protocolo de transcripción v2.0.77</p>
        </header>

        <main class="cyber-panel p-6 rounded-lg space-y-6">
            <!-- Paso 1: Carga de Archivo -->
            <div id="upload-section">
                <h2 class="text-2xl text-fuchsia-400 border-b border-fuchsia-500 pb-2 mb-4">1. Inyección de Datos de Audio</h2>
                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 bg-black/20 p-4 border border-dashed border-cyan-400 rounded">
                    <div class="file-input-wrapper">
                        <button class="cyber-button" id="upload-label">Seleccionar Archivo</button>
                        <input type="file" id="audio-file" accept="audio/*">
                    </div>
                    <span id="file-name" class="text-gray-400">Ningún archivo seleccionado...</span>
                </div>
            </div>

            <!-- Paso 2: Proceso y Resultados -->
            <div id="processing-section" class="space-y-4">
                 <h2 class="text-2xl text-fuchsia-400 border-b border-fuchsia-500 pb-2 mb-4">2. Matriz de Transcripción</h2>
                <button id="transcribe-button" class="cyber-button w-full" disabled>Iniciar Transcripción</button>
                
                <div id="status" class="text-center text-yellow-400 h-6"></div>

                <textarea id="transcription-output" class="w-full h-64 p-2 rounded-md transition-all duration-300" placeholder="...esperando flujo de datos de texto..." readonly></textarea>
            </div>

            <!-- Paso 3: Descarga -->
            <div id="download-section" class="space-y-4">
                 <h2 class="text-2xl text-fuchsia-400 border-b border-fuchsia-500 pb-2 mb-4">3. Exportar Datos</h2>
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="download-pdf" class="cyber-button w-full sm:w-auto" disabled>Descargar PDF</button>
                    <button id="download-doc" class="cyber-button w-full sm:w-auto" disabled>Descargar Word (.doc)</button>
                </div>
            </div>
        </main>

        <footer class="text-center mt-8 text-xs text-gray-500">
            <p>© 2077 Cyber-Scribe Industries. Todos los derechos reservados.</p>
            <p class="text-fuchsia-600">DESARROLLADO POR INGENIERO CAMILO ANDRES SERRANO SANCHEZ</p>
        </footer>
    </div>

    <script>
        // --- REFERENCIAS A ELEMENTOS DEL DOM ---
        const audioFileInput = document.getElementById('audio-file');
        const fileNameDisplay = document.getElementById('file-name');
        const transcribeButton = document.getElementById('transcribe-button');
        const statusDisplay = document.getElementById('status');
        const transcriptionOutput = document.getElementById('transcription-output');
        const downloadPdfButton = document.getElementById('download-pdf');
        const downloadDocButton = document.getElementById('download-doc');
        const uploadLabel = document.getElementById('upload-label');

        let selectedFile = null;

        // --- LÓGICA DE LA APLICACIÓN ---

        // 1. Manejo de la selección de archivos
        audioFileInput.addEventListener('change', (event) => {
            selectedFile = event.target.files[0];
            if (selectedFile) {
                fileNameDisplay.textContent = selectedFile.name;
                fileNameDisplay.classList.remove('text-gray-400');
                fileNameDisplay.classList.add('text-cyan-400');
                transcribeButton.disabled = false;
                uploadLabel.textContent = 'Archivo Cargado';
            } else {
                fileNameDisplay.textContent = 'Ningún archivo seleccionado...';
                fileNameDisplay.classList.add('text-gray-400');
                fileNameDisplay.classList.remove('text-cyan-400');
                transcribeButton.disabled = true;
                uploadLabel.textContent = 'Seleccionar Archivo';
            }
        });

        // 2. Botón de transcripción
        transcribeButton.addEventListener('click', async () => {
            if (!selectedFile) return;

            // Deshabilitar botones durante el proceso
            transcribeButton.disabled = true;
            downloadPdfButton.disabled = true;
            downloadDocButton.disabled = true;
            transcriptionOutput.value = '';
            statusDisplay.textContent = 'Iniciando análisis de audio...';

            try {
                // Simulación del proceso de chunking y transcripción
                const fullText = await processAudio(selectedFile);
                transcriptionOutput.value = fullText;
                transcriptionOutput.readOnly = false; // Permitir edición
                
                // Habilitar botones de descarga
                downloadPdfButton.disabled = false;
                downloadDocButton.disabled = false;
                statusDisplay.textContent = 'Transcripción completada. Sistema en espera.';

            } catch (error) {
                console.error("Error en el proceso:", error);
                statusDisplay.textContent = `Error de sistema: ${error.message}`;
                statusDisplay.classList.add('text-red-500');
            } finally {
                // Volver a habilitar el botón de transcripción
                transcribeButton.disabled = false;
            }
        });
        
        /**
         * Simula el proceso de dividir el audio en partes (chunks),
         * transcribir cada parte y luego unirlas.
         * @param {File} file - El archivo de audio a procesar.
         * @returns {Promise<string>} - El texto completo transcrito.
         */
        async function processAudio(file) {
            // Usamos la Web Audio API para obtener la duración del audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const duration = audioBuffer.duration;

            const CHUNK_DURATION_SECONDS = 30; // Dividir en chunks de 30 segundos
            const numChunks = Math.ceil(duration / CHUNK_DURATION_SECONDS);
            let fullTranscription = `INICIO DE TRANSCRIPCIÓN - Archivo: ${file.name}\nDuración Total: ${duration.toFixed(2)}s - Chunks: ${numChunks}\n\n---\n\n`;

            for (let i = 0; i < numChunks; i++) {
                statusDisplay.textContent = `Procesando chunk ${i + 1} de ${numChunks}...`;
                
                // Simulación de la llamada a una API de transcripción para este chunk
                const chunkText = await simulateTranscription(i, CHUNK_DURATION_SECONDS);
                
                const startTime = (i * CHUNK_DURATION_SECONDS).toFixed(1);
                fullTranscription += `[${startTime}s] ${chunkText}\n\n`;
                
                // Actualizar el textarea en tiempo real
                transcriptionOutput.value = fullTranscription;
                transcriptionOutput.scrollTop = transcriptionOutput.scrollHeight;
            }
            
            fullTranscription += "---\n\nFIN DE TRANSCRIPCIÓN.";
            return fullTranscription;
        }

        /**
         * Simula una llamada a una API de Speech-to-Text.
         * En una aplicación real, aquí se enviaría el chunk de audio
         * a un servicio como Google Speech-to-Text, AssemblyAI, etc.
         * @param {number} chunkIndex - El índice del chunk.
         * @returns {Promise<string>} - Un texto de ejemplo.
         */
        function simulateTranscription(chunkIndex) {
            return new Promise(resolve => {
                // Simula el tiempo de espera de una llamada de red
                setTimeout(() => {
                    const placeholderTexts = [
                        "Analizando patrones de voz... se detecta una anomalía en el sector 7G.",
                        "La transferencia de datos cuánticos parece estable, pero la encriptación es de nivel corporativo.",
                        "Mencionan un 'Proyecto Quimera'. Necesitamos más datos para triangular la ubicación.",
                        "El sujeto parece estar negociando un artefacto de la Vieja Red. Es tecnología pre-colapso.",
                        "Se detectan interferencias. Posiblemente un 'netrunner' intentando ocultar la transmisión.",
                        "Confirmado, el punto de encuentro es en el distrito de neón, cerca del viejo mercado de cromo.",
                        "La contraseña es 'Orión'. Repito, la contraseña es 'Orión'. Procedan con cautela.",
                    ];
                    const text = placeholderTexts[chunkIndex % placeholderTexts.length];
                    resolve(text);
                }, 1000 + Math.random() * 1000); // Delay aleatorio entre 1 y 2 segundos
            });
        }

        // 3. Lógica de descarga
        
        // Descargar como PDF
        downloadPdfButton.addEventListener('click', () => {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const text = transcriptionOutput.value;
            // jsPDF maneja el ajuste de línea automáticamente
            const lines = doc.splitTextToSize(text, 180); // 180 es el ancho del área de texto

            doc.setFont('courier');
            doc.setFontSize(10);
            doc.text(lines, 15, 20);
            doc.save(`transcripcion_${selectedFile.name}.pdf`);
        });

        // Descargar como Word (.doc)
        downloadDocButton.addEventListener('click', () => {
            const header = "<html xmlns:o='urn:schemas-microsoft-com:office:office' "+
            "xmlns:w='urn:schemas-microsoft-com:office:word' "+
            "xmlns='http://www.w3.org/TR/REC-html40'>"+
            "<head><meta charset='utf-8'><title>Transcripción</title></head><body>";
            const footer = "</body></html>";
            
            // Reemplazar saltos de línea con <br> para formato HTML
            const content = transcriptionOutput.value.replace(/\n/g, '<br>');
            
            const sourceHTML = header + content + footer;
            
            const source = 'data:application/vnd.ms-word;charset=utf-8,' + encodeURIComponent(sourceHTML);
            const fileDownload = document.createElement("a");
            document.body.appendChild(fileDownload);
            fileDownload.href = source;
            fileDownload.download = `transcripcion_${selectedFile.name}.doc`;
            fileDownload.click();
            document.body.removeChild(fileDownload);
        });

    </script>
</body>
</html>
